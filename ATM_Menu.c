#pragma config(Hubs,  S1, HTMotor,  HTServo,  HTMotor,  HTMotor)
#pragma config(Sensor, S2,     encoder,        sensorLightActive)
#pragma config(Sensor, S3,     stopper,        sensorTouch)
#pragma config(Sensor, S4,     HTIRS2,         sensorI2CCustom)
#pragma config(Motor,  motorA,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  motorB,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  motorC,           ,             tmotorNXT, openLoop)
#pragma config(Motor,  mtr_S1_C1_1,     motorUL,        tmotorTetrix, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     motorUR,        tmotorTetrix, PIDControl, reversed, encoder)
#pragma config(Motor,  mtr_S1_C3_1,     arm,           tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C3_2,     flag,          tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C4_1,     motorDL,       tmotorTetrix, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C4_2,     motorDR,       tmotorTetrix, PIDControl, reversed, encoder)
#pragma config(Servo,  srvo_S1_C2_1,    armleft,              tServoStandard)
#pragma config(Servo,  srvo_S1_C2_2,    armright,             tServoStandard)
#pragma config(Servo,  srvo_S1_C2_3,    pinballleft,          tServoStandard)
#pragma config(Servo,  srvo_S1_C2_4,    pinballright,         tServoStandard)
#pragma config(Servo,  srvo_S1_C2_5,    flagservo,            tServoStandard)
#pragma config(Servo,  srvo_S1_C2_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//
//#pragma DebuggerWindows ("nxtLcdScreen")
//#pragma DebuggerWindows ("Globals")

#include "JoystickDriver.c"
#include "drivers/hitechnic-irseeker-v2.h"

//define ArmReset; ArmReset(); //DO NOT UNCOMMENT

// Variables for ATM Menu
int linepos = 0;
int delay = 0;
int buttontime = 0;
int pgmcnt = 1; //max = 9? 10? (come back to this later)
bool wait = false;
bool endselect = false;
bool wait500 = false;
bool stopit = false;
bool stopwhile = false;
string waitword = "No";
string pgmname;
string stngfmt;
string select1 = "*";
string select2;
string select3;
string select4;

int dist2Basket = 0;
int rt_adj = 750;
int fss_adj = 0;
int fss_arm_adj = 0;
int sdrff_adj = 150;
bool lastbasket = false;
bool dffrlast = false;
bool dffr2ndlast = false;
bool parkfar = false;
string parkword = "Near";

//VARIABLES AND VOIDS FOR ATM Routines
// 90 degree Turn
const int RT90 = 2500;
const int LT90 = 2500;

const int RTADJ1 = 50;
const int RTADJ2 = 150;
const int RTADJ3 = 250;
const int RTADJ4 = 350;

const int SLIDE_1IN = 155; // Slide move on the side
const int STRAIGHT_1IN = 125;
const double SLD2STR = 155/125;
const double STR2SLD = 125/155;
// ATM DFF Left move distance
int dist2End;		// Variable distances to End
const int DIST_2B4 = 12*SLIDE_1IN;
const int DIST_B42B3 = 10*SLIDE_1IN;
const int DIST_B32B2 = 19*SLIDE_1IN;
const int DIST_B22B1 = 12*SLIDE_1IN;

const int DIST_2END = 71*SLIDE_1IN;
const int DIST_2ENDS = 68*SLIDE_1IN;
const int DIST_2LINE = 37*STRAIGHT_1IN;
const int DIST_2RAMP = 48*STRAIGHT_1IN;
const int DIST_2FAR  = 16*STRAIGHT_1IN;
const int DIST_2RAMP2 = 41*STRAIGHT_1IN;


// ATM DFF Right move distance
const int DIST_2B1   = 10*SLIDE_1IN;
const int DIST_B12B2 = 10*SLIDE_1IN;
const int DIST_B22B3 = 20*SLIDE_1IN;
//const int DIST_B22B3r = 21*SLIDE_1IN;
const int DIST_B32B4 = 11*SLIDE_1IN;
const int DIST_2ENDR = 76*SLIDE_1IN;
const int DIST_2ENDRn = 56*SLIDE_1IN;
const int DIST_2LINER = 36*STRAIGHT_1IN;
const int DIST_DFFRMOV = 12*SLIDE_1IN;
const int DIST_DFFRMOV2 = 15*SLIDE_1IN;

// ATM LTTR and RTTR move distances
const int DIST_STBS = 12*STRAIGHT_1IN;
const int DIST_BSTW = 22*SLIDE_1IN;
const int DIST_WTRS = 34*STRAIGHT_1IN;
const int DIST_RTRC = 27*STRAIGHT_1IN;

// ATM DFR move distances
const int DIST_B2T3   = 18*SLIDE_1IN;
const int DIST_B3T4   = 10*SLIDE_1IN;
const int DIST_2B4R   = 10*SLIDE_1IN;
const int DIST_B32B2R = 21*SLIDE_1IN;
const int DIST_B22B1R = 11*SLIDE_1IN;
const int DIST_IDK    =  7*SLIDE_1IN;
const int DIST_1IN    =  1*SLIDE_1IN;

// ATM DRFF move distances
const int DIST_B22B3r = 19*SLIDE_1IN;
const int DIST_2B1r = 9*SLIDE_1IN;
const int DIST_2LINEr = 37*STRAIGHT_1IN;
const int DIST_2LINEn = 20*SLIDE_1IN;
const int DIST_2B4r = 11*SLIDE_1IN;
const int DFFR_LBADJ = 2*STRAIGHT_1IN;
const int DFFR_LBT2 = 800;
const int DIST_B32B2r = 19*SLIDE_1IN;

// ATM SDRFF move distances
const int DIST_2RAMPS = 34*STRAIGHT_1IN;
const int DIST_SFOR   =  17*SLIDE_1IN;

// ATM DFFFSS move distances
const int DIST_INT_FSS = 16 * SLIDE_1IN;
const int DIST_BCK_FSS = 15 * STRAIGHT_1IN;
const int DIST_2BK_FSS = 23 * STRAIGHT_1IN;
const int DIST_AF1_FSS =  7 * STRAIGHT_1IN;
const int DFFFSSADJ    = 200;

// ATM speed constants
const int SPD_TRN = 65;
const int SPD_STR = 65;
const int SPD_SLD = 65;
const int SPD_ADJ = 40;

// ATM dump number
const int RAISENUM = 13;

// ATM DFF Turn
const int DFF_TURN = 200;

// HitecIRS AC directional values.
int _dirAC = 0;
// AC values from 5 internal detectors.
int acS1, acS2, acS3, acS4, acS5 = 0;
bool foundBeacon = false;

//***   Right Turn 90 degree   ***//
void TurnRight (int distance, int speed, bool ResetArm)
{
	nMotorEncoder[motorUR] = 0;
	nMotorEncoder[motorUL] = 0;
	nMotorEncoder[motorDR] = 0;
	nMotorEncoder[motorDL] = 0;
	nMotorEncoderTarget[motorUR] = distance*-1;
	nMotorEncoderTarget[motorUL] = distance;
	nMotorEncoderTarget[motorDR] = distance*-1;
	nMotorEncoderTarget[motorDL] = distance;

	motor[motorUR] = speed*-1;
	motor[motorUL] = speed;
	motor[motorDR] = speed*-1;
	motor[motorDL] = speed;

	if(ResetArm == true && SensorValue[stopper] != 1)
	{
		motor[arm] = -60;
	}
	else
	{
		motor[arm] = 0;
	}

	while(nMotorRunState[motorUR] != runStateIdle && nMotorRunState[motorUL] != runStateIdle
		&& nMotorRunState[motorDR] != runStateIdle && nMotorRunState[motorDL] != runStateIdle)
	{
		//Loop till target Encoder is reached
	}

	motor[motorUR] = 0;
	motor[motorUL] = 0;
	motor[motorDR] = 0;
	motor[motorDL] = 0;
	wait1Msec(200);

	nMotorEncoder[motorUR] = 0;
	nMotorEncoder[motorUL] = 0;
	nMotorEncoder[motorDR] = 0;
	nMotorEncoder[motorDL] = 0;
}

//***   Left Turn 90 degree   ***//
void TurnLeft (int distance, int speed, bool ResetArm)
{
	nMotorEncoder[motorUR] = 0;
	nMotorEncoder[motorUL] = 0;
	nMotorEncoder[motorDR] = 0;
	nMotorEncoder[motorDL] = 0;
	nMotorEncoderTarget[motorUR] = distance;
	nMotorEncoderTarget[motorUL] = distance*-1;
	nMotorEncoderTarget[motorDR] = distance;
	nMotorEncoderTarget[motorDL] = distance*-1;

	motor[motorUR] = speed;
	motor[motorUL] = speed*-1;
	motor[motorDR] = speed;
	motor[motorDL] = speed*-1;

	if(ResetArm == true && SensorValue[stopper] != 1)
	{
		motor[arm] = -60;
	}
	else
	{
		motor[arm] = 0;
	}

	while(nMotorRunState[motorUR] != runStateIdle && nMotorRunState[motorUL] != runStateIdle
		&& nMotorRunState[motorDR] != runStateIdle && nMotorRunState[motorDL] != runStateIdle)
	{
		//Loop till target Encoder is reached
	}

	motor[motorUR] = 0;
	motor[motorUL] = 0;
	motor[motorDR] = 0;
	motor[motorDL] = 0;
	wait1Msec(200);

	nMotorEncoder[motorUR] = 0;
	nMotorEncoder[motorUL] = 0;
	nMotorEncoder[motorDR] = 0;
	nMotorEncoder[motorDL] = 0;
}

//***   Slide to the Right   ***//
void SlideRight(int distance, int speed, bool ResetArm)
{
	stopwhile = false;
	nMotorEncoder[motorUR] = 0;
	nMotorEncoder[motorUL] = 0;
	nMotorEncoder[motorDR] = 0;
	nMotorEncoder[motorDL] = 0;
	nMotorEncoderTarget[motorUR] = distance*-1;
	//nMotorEncoderTarget[motorUL] = distance;
	//nMotorEncoderTarget[motorDR] = distance;
	nMotorEncoderTarget[motorDL] = distance*-1;

	motor[motorUR] = speed*-1;
	motor[motorUL] = speed*1; // Adjust speed for parallel side move
	motor[motorDR] = speed*0.8; //0.85; // Adjust speed for parallel side move
	motor[motorDL] = speed*-1;

	if(ResetArm == true && SensorValue[stopper] != 1)
	{
		motor[arm] = -60;
	}
	else
	{
		motor[arm] = 0;
	}

	//while(nMotorRunState[motorUR] != runStateIdle && nMotorRunState[motorUL] != runStateIdle
	//	    && nMotorRunState[motorDR] != runStateIdle && nMotorRunState[motorDL] != runStateIdle)

	while(nMotorRunState[motorUR] != runStateIdle && nMotorRunState[motorDL] != runStateIdle)
		// Check only 2 drives that have target set
	{
		//Loop till target Encoder is reached
		if(SensorValue[stopper] == 1)
		{
			motor[arm] = 0;
		}
	}

	//while (stopwhile == false)
	//{
	//	if(nMotorRunState[motorUR] == runStateIdle || nMotorRunState[motorUL] == runStateIdle
	//	    || nMotorRunState[motorDR] == runStateIdle || nMotorRunState[motorDL] == runStateIdle)
	//	{
	//		stopwhile = true;
	//	}
	//	//Loop till target Encoder is reached
	//	if(SensorValue[stopper] == 1)
	//	{
	//		motor[arm] = 0;
	//	}
	//}

	motor[arm] = 0;
	motor[motorUR] = 0;
	motor[motorUL] = 0;
	motor[motorDR] = 0;
	motor[motorDL] = 0;
	wait1Msec(200);

	nMotorEncoder[motorUR] = 0;
	nMotorEncoder[motorUL] = 0;
	nMotorEncoder[motorDR] = 0;
	nMotorEncoder[motorDL] = 0;
}

//***   Slide to the Left   ***//
void SlideLeft(int distance, int speed, bool ResetArm)
{
	stopwhile = false;
	nMotorEncoder[motorUR] = 0;
	nMotorEncoder[motorUL] = 0;
	nMotorEncoder[motorDR] = 0;
	nMotorEncoder[motorDL] = 0;
	//nMotorEncoderTarget[motorUR] = distance;
	nMotorEncoderTarget[motorUL] = distance*-1;
	nMotorEncoderTarget[motorDR] = distance*-1;
	//nMotorEncoderTarget[motorDL] = distance;

	motor[motorUR] = speed; //*0.9;
	motor[motorUL] = speed*-1;
	motor[motorDR] = speed*-1;
	motor[motorDL] = speed*0.8; // Left Slide, adjust speed only this drive

	if(ResetArm == true && SensorValue[stopper] != 1)
	{
		motor[arm] = -60;
	}
	else
	{
		motor[arm] = 0;
	}

	while(nMotorRunState[motorDR] != runStateIdle && nMotorRunState[motorUL] != runStateIdle)
		//Check only 2 drives drives that have target set
	{
		//Loop till target Encoder is reached
		if(SensorValue[stopper] == 1)
		{
			motor[arm] = 0;
		}
	}

	motor[arm] = 0;
	motor[motorDR] = 0;
	motor[motorDL] = 0;
	motor[motorUR] = 0;
	motor[motorUL] = 0;

	wait1Msec(200);

	nMotorEncoder[motorUR] = 0;
	nMotorEncoder[motorUL] = 0;
	nMotorEncoder[motorDR] = 0;
	nMotorEncoder[motorDL] = 0;
}

//***   Straight Move   ***//
void MoveStraight (int distance, int speed, bool ResetArm)
{
	nMotorEncoder[motorUR] = 0;
	nMotorEncoder[motorUL] = 0;
	nMotorEncoder[motorDL] = 0;
	nMotorEncoder[motorDR] = 0;
	nMotorEncoderTarget[motorUR] = distance;
	nMotorEncoderTarget[motorUL] = distance;
	nMotorEncoderTarget[motorDR] = distance;
	nMotorEncoderTarget[motorDL] = distance;
	motor[motorUR] = speed;
	motor[motorUL] = speed;
	motor[motorDR] = speed;
	motor[motorDL] = speed;

	if(ResetArm == true && SensorValue[stopper] != 1)
	{
		motor[arm] = -60;
	}
	else
	{
		motor[arm] = 0;
	}

	while(nMotorRunState[motorUR] != runStateIdle && nMotorRunState[motorUL] != runStateIdle
		&& nMotorRunState[motorDR] != runStateIdle && nMotorRunState[motorDL] != runStateIdle)
	{
		//Loop till target Encoder is reached
		if(SensorValue[stopper] == 1)
		{
			motor[arm] = 0;
		}
	}

	motor[arm] = 0;
	motor[motorUR] = 0;	motor[motorUL] = 0;
	motor[motorDR] = 0;
	motor[motorDL] = 0;

	wait1Msec(200);

	nMotorEncoder[motorUR] = 0;
	nMotorEncoder[motorUL] = 0;
	nMotorEncoder[motorDR] = 0;
	nMotorEncoder[motorDL] = 0;
}

//***   Raise the Arm   ***//
void RaiseArm (int arm_angle)
{
	int linecnt = 0;
	int threshhold = 45;
	bool lastblack = false;

//	ClearTimer(T1);

	while(linecnt < arm_angle)
	{
/*		if(time1[T1] >= 9000)
		{
			break;
		}
*/
		if(SensorValue[encoder] < threshhold)
		{
			if(lastblack == true)
			{
				linecnt++;
				lastblack = false;
			}
		}
		else
		{
			lastblack = true;
		}
		motor[arm] = 60;
	}

	motor[arm] = 0;


}

//***   Lower Arm   ***//
void LowerArm (int arm_angle)
{
	int linecnt = 0;
	int threshhold = 45;
	bool lastblack = false;

//	ClearTimer(T1);

	while(linecnt < arm_angle && SensorValue[stopper] != 1)
	{
/*		if(time1[T1] >= 9000)
		{
			break;
		}*/
		if(SensorValue[encoder] < threshhold)
		{

			if(lastblack == true)
			{
				linecnt++;
				lastblack = false;
			}
		}
		else
		{
			lastblack = true;
		}
		motor[arm] = -60;
	}
	motor[arm] = 0;
}

//***   Arm Reset   ***//
void ArmReset()
{
	while(SensorValue[stopper] != 1 && waitword == "No")
	{
		motor[arm] = -60;
	}
	motor[arm] = 0;
}

task TaskArmReset
{
	while(SensorValue[stopper] != 1 && wait == false)
	{
		motor[arm] = -60;
	}
	motor[arm] = 0;
}

//***   Dump the block   ***//
void Dump(void)
{
	//open dump
	servo[pinballleft] = 127;
	servo[pinballright] = 128;
	wait1Msec(800);

	// Close pinball
	servo[pinballleft] = 255;
	servo[pinballright] = 0;
	servo[flagservo] = 0;
	wait1Msec(200);
}

//*** Check Beacon, Straight ***//
void CheckBeacon(void)
{
	// read the current modulated signal direction
	_dirAC = HTIRS2readACDir(HTIRS2);
	if (_dirAC < 0)
		foundBeacon = false; // I2C read error occurred

	if (!HTIRS2readAllACStrength(HTIRS2, acS1, acS2, acS3, acS4, acS5 ))
		foundBeacon = false; // I2C read error occurred

	if (_dirAC == 5 && acS3 > 70)
	{
		foundBeacon = true;
	}
	else
	{
		foundBeacon = false;
	}
}

////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////////////

//VARIABLES AND VOIDS FOR DEMO
int distR;
int distL;

bool lastblack = false;
int linecnt = 0;
const int threshhold = 45;
////////////////////////////////////////////////////////////////////////////////////////


//******************** Dump From Floor, Left slide (DFF_L)  **************************//
task DFF_L()
{

	// Slide left to in front of each basket
	if (foundBeacon == false)
	{
		SlideLeft(DIST_2B4, SPD_SLD, false);
		wait1Msec(100);
		//MoveStraight(SLIDE_1IN*-0.25,SPD_SLD*-1,false);
		CheckBeacon();
		if (foundBeacon == true)
		{
			dist2End = DIST_2END - DIST_2B4 + 8*SLIDE_1IN;
			rt_adj = RTADJ1;
		}
	}

	if (foundBeacon == false)
	{
		SlideLeft(DIST_B42B3, SPD_SLD, false);
		wait1Msec(100);
		//MoveStraight(SLIDE_1IN*-0.5,SPD_ADJ*-1,false);
		CheckBeacon();
		if (foundBeacon == true)
		{
			dist2End = DIST_2END + 8*SLIDE_1IN - (DIST_2B4+DIST_B42B3);
			rt_adj = RTADJ2;
		}
	}

	if (foundBeacon == false)
	{
		SlideLeft(DIST_B32B2, SPD_SLD, false);
		wait1Msec(100);
		CheckBeacon();
		if (foundBeacon == true)
		{
			dist2End = DIST_2END + 8*SLIDE_1IN- (DIST_2B4+DIST_B42B3+DIST_B32B2);
			rt_adj = RTADJ3;
			MoveStraight(STRAIGHT_1IN*2,SPD_ADJ,false);
		}
	}

	if (foundBeacon == false)
	{
		SlideLeft(DIST_B22B1, SPD_SLD, false);
		MoveStraight(STRAIGHT_1IN*2,SPD_ADJ,false);
		wait1Msec(100);
		//MoveStraight(SLIDE_1IN*-1.5, SPD_ADJ*-1, false);
		// last basket, No need to check
		foundBeacon = true;
		dist2End = DIST_2END + 8*SLIDE_1IN - (DIST_2B4+DIST_B42B3+DIST_B32B2+DIST_B22B1);
		rt_adj = RTADJ4;
	}

	wait1Msec(200);

	if (foundBeacon == true)
	{
		//TurnLeft(LT_ADJ,30);
		RaiseArm(14);
		Dump();
		//LowerArm(8);
		servo[flagservo] = 240;
		wait1Msec(100);
		LowerArm(13);
		//ArmReset();

		SlideLeft(dist2End, SPD_SLD, false);
		MoveStraight(DIST_2LINE, SPD_STR, false);
		TurnRight(RT90+rt_adj, SPD_TRN, false);
		MoveStraight(DIST_2RAMP - 8*STRAIGHT_1IN, SPD_STR, false);

		if(parkfar == true)
		{
			MoveStraight(DIST_2FAR, SPD_STR, false);
		}

		ArmReset();

	}

	stopit = true;
}

//******************** Dump From Floor, Right slide (DFF_R)  **************************//
task DFF_R()
{
	// Slide right to in front of each basket
	if (foundBeacon == false)
	{
		SlideRight(DIST_2B1, SPD_SLD, false);
		CheckBeacon();
		if (foundBeacon == true)
		{
			dist2End = DIST_2ENDR - DIST_2B1;
		}
	}

	if (foundBeacon == false)
	{
		SlideRight(DIST_B12B2, SPD_SLD, false);
		CheckBeacon();
		if (foundBeacon == true)
		{
			dist2End = DIST_2ENDR - (DIST_2B1+DIST_B12B2);
		}
	}

	if (foundBeacon == false)
	{
		SlideRight(DIST_B22B3, SPD_SLD, false);
		CheckBeacon();
		if (foundBeacon == true)
		{
			dist2End = DIST_2ENDR - (DIST_2B1+DIST_B12B2+DIST_B22B3);
		}
	}

	if (foundBeacon == false)
	{
		SlideRight(DIST_B32B4, SPD_SLD, false);
		// last basket, No need to check
		foundBeacon = true;
		dist2End = DIST_2ENDR - (DIST_2B1+DIST_B12B2+DIST_B22B3+DIST_B32B4);
	}

	wait1Msec(200);

	if (foundBeacon == true)
	{
//  	TurnRight(DFF_TURN, SPD_TRN);
		RaiseArm(RAISENUM);
		Dump();
		servo[flagservo] = 240;
		wait1Msec(100);
		//ArmReset();
		LowerArm(13);
		SlideRight(dist2End, SPD_SLD, false);
		MoveStraight(DIST_2LINER, SPD_STR, false);
		TurnLeft(LT90+500, SPD_TRN, false);
		MoveStraight(DIST_2RAMP, SPD_STR, false);

		if(parkfar == true)
		{
			MoveStraight(DIST_2FAR, SPD_STR, true);
		}

		//StartTask(TaskArmReset);
		ArmReset();
	}

	stopit = true;
}

//******************** Dump and Retreat From Floor, Left slide (DRFF_L)  **************************//
task DRFF_L()
{

	// Slide left to in front of each basket
	if (foundBeacon == false)
	{
		SlideLeft(DIST_2B4r, SPD_SLD, false);
		wait1Msec(100);
		//MoveStraight(SLIDE_1IN*-0.25,SPD_ADJ*-1,false);
		CheckBeacon();
		if (foundBeacon == true)
		{
			MoveStraight(STRAIGHT_1IN, SPD_STR, false);
		//TurnRight(DRFFLADJ1, 40);
			dist2End = DIST_2END - (DIST_2B4+DIST_B42B3+DIST_B32B2+DIST_B22B1); //4
			rt_adj = RTADJ1;
		}
	}

	if (foundBeacon == false)
	{
		SlideLeft(DIST_B42B3, SPD_SLD, false);
		wait1Msec(100);
		//MoveStraight(SLIDE_1IN*-0.5, SPD_ADJ*-1, false);
		CheckBeacon();
		if (foundBeacon == true)
		{
			//TurnRight(DRFFLADJ2, 40);
			MoveStraight(DIST_1IN*3, SPD_STR, false);
			dist2End = DIST_2END - (DIST_2B4+DIST_B42B3+DIST_B32B2); //3
			rt_adj = RTADJ2;
		}
	}

	if (foundBeacon == false)
	{
		SlideLeft(DIST_B32B2r, SPD_SLD, false);
		wait1Msec(100);
		//MoveStraight(SLIDE_1IN*-1,SPD_ADJ*-1,false);
		CheckBeacon();
		if (foundBeacon == true)
		{
			//TurnRight(DRFFLADJ3, 40);
			dist2End = DIST_2END - (DIST_2B4+DIST_B42B3); //2
			dffr2ndlast = true;
			MoveStraight(DIST_1IN*2, SPD_STR, false);
			rt_adj = RTADJ3;
		}
	}

	if (foundBeacon == false)
	{
		//	SlideLeft(DIST_B22B1, 65, false);
		//	wait1Msec(100);
		//MoveStraight(SLIDE_1IN*-1,-30,false);
		// last basket, No need to check
		dffrlast = true;
		rt_adj = RTADJ4;
		TurnLeft(DFFR_LBT2, SPD_TRN, false);
		MoveStraight(DIST_1IN*3, SPD_STR, false);
		foundBeacon = true;
		//TurnRight(DRFFLADJ4, 40);
		//dist2End = DIST_2END - DIST_2B4; //1
		dist2End = DIST_2END - (DIST_2B4+DIST_B42B3); //2 too
	}

	wait1Msec(200);

	if (foundBeacon == true)
	{
		RaiseArm(RAISENUM);
		Dump();
		LowerArm(8);
		servo[flagservo] = 240;
		wait1Msec(100);
		//ArmReset();

		if(dffrlast == true)
		{
			TurnRight(DFFR_LBT2, SPD_TRN, false);
			LowerArm(3);
			SlideRight(DIST_DFFRMOV, SPD_SLD, false);
			LowerArm(10);
			dist2End = dist2End - DIST_DFFRMOV;
		}
		else if(dffr2ndlast == true)
		{
			LowerArm(3);
			SlideRight(DIST_DFFRMOV2, SPD_SLD, false);
			LowerArm(10);
			dist2End = dist2End - DIST_DFFRMOV;
		}
		else
		{
			LowerArm(13);
		}

		SlideRight(dist2End, SPD_SLD, false);
		MoveStraight(DIST_2LINEr, SPD_STR, false);
		TurnLeft(LT90+500, SPD_TRN, false);
		MoveStraight(DIST_2RAMP-9*SLIDE_1IN, SPD_STR, false);

		if(parkfar == true)
		{
			MoveStraight(DIST_2FAR, SPD_STR, true);
		}

		ArmReset();

	}

	stopit = true;
}

//******************** Dump and Retreat From Floor, Right slide (DRFF_R)  **************************//
task DRFF_R()
{

	// Slide left to in front of each basket
	if (foundBeacon == false)
	{
		SlideRight(DIST_2B1r, SPD_SLD, false);
		CheckBeacon();
		if (foundBeacon == true)
		{
			dist2End = DIST_2END - (DIST_2B1+DIST_B12B2+DIST_B22B3+DIST_B32B4); //4
		}
	}

	if (foundBeacon == false)
	{
		SlideRight(DIST_B12B2, SPD_SLD, false);
		CheckBeacon();
		if (foundBeacon == true)
		{
			dist2End = DIST_2END - (DIST_2B1+DIST_B12B2+DIST_B22B3); //3
		}
	}

	if (foundBeacon == false)
	{
		SlideRight(DIST_B22B3, SPD_SLD, false);
		CheckBeacon();
		if (foundBeacon == true)
		{
			dist2End = DIST_2END - (DIST_2B1+DIST_B12B2); //2
			dffr2ndlast = true;
		}
	}

	if (foundBeacon == false)
	{
		dffrlast = true;
		TurnRight(DFFR_LBT2, SPD_TRN, false);
		MoveStraight(DFFR_LBADJ, SPD_STR, false);
		//	SlideRight(DIST_B32B4, 55, false);
		// last basket, No need to check
		foundBeacon = true;
		dist2End = DIST_2END - (DIST_2B1+DIST_B12B2); //also 2
	}

	wait1Msec(200);

	if (foundBeacon == true)
	{
		RaiseArm(RAISENUM);
		Dump();
		LowerArm(8);
		servo[flagservo] = 240;
		wait1Msec(100);

		if(dffrlast == true)
		{
			TurnLeft(DFFR_LBT2, SPD_TRN, false);
			LowerArm(6);
			SlideLeft(DIST_DFFRMOV, SPD_SLD, false);
			LowerArm(7);
			dist2End = dist2End - DIST_DFFRMOV;
		}
		else if(dffr2ndlast == true)
		{
			LowerArm(3);
			SlideLeft(DIST_DFFRMOV2, SPD_SLD, false);
			LowerArm(10);
			dist2End = dist2End - DIST_DFFRMOV;
		}
		else
		{
			LowerArm(13);
		}

		SlideLeft(dist2End, SPD_SLD, false);
		MoveStraight(DIST_2LINE, SPD_STR, false);
		TurnRight(RT90, SPD_TRN, false);
		MoveStraight(DIST_2RAMP2-8*STRAIGHT_1IN, SPD_STR, false);

		if(parkfar == true)
		{
			MoveStraight(DIST_2FAR, SPD_STR, true);
		}

		StartTask(TaskArmReset);

	}

	stopit = true;
}

//******************** Left Turn To Ramp (LTTR) ****************************************//
task LTTR()
{
	MoveStraight(DIST_STBS, SPD_STR, false);
	RaiseArm(RAISENUM);
	Dump();
	servo[flagservo] = 240;
	StartTask(TaskArmReset);
	SlideRight(DIST_BSTW, SPD_SLD, false);
	MoveStraight(DIST_WTRS, SPD_STR, false);
	TurnLeft(LT90+650, SPD_TRN, false);
	MoveStraight(DIST_RTRC+STRAIGHT_1IN*20, SPD_STR, false);


	if(parkfar == true)
	{
		MoveStraight(DIST_2FAR, SPD_STR, true);
	}

	stopit = true;
}

//******************** Right Turn To Ramp (RTTR) ****************************************//
task RTTR
{
	MoveStraight(DIST_STBS, SPD_STR, false);
	RaiseArm(RAISENUM);
	Dump();
	servo[flagservo] = 240;
	StartTask(TaskArmReset);
	SlideLeft(DIST_BSTW, SPD_SLD, false);
	MoveStraight(DIST_WTRS, SPD_STR, false);
	TurnRight(RT90+650, SPD_TRN, false);
	MoveStraight(DIST_RTRC+STRAIGHT_1IN*20, SPD_STR, false);

	if(parkfar == true)
	{
		MoveStraight(DIST_2FAR, SPD_STR, true);
	}


	stopit = true;
}

//********************************** Demo Code ****************************************//
task Demo()
{
	// Initialize Servo positions
	servo[armleft] = 245;
	servo[armright] = 10;
	servo[pinballleft] = 255;
	servo[pinballright] = 0;
	wait1Msec(1000);

	servo[flagservo] = 255;
	wait1Msec(1000);

	// Run Drive Motor Forward
	motor[motorUR] = 60;
	motor[motorUL] = 60;
	motor[motorDL] = 60;
	motor[motorDR] = 60;
	wait1Msec(2000);
	// Run Drive Motor Backward
	motor[motorUR] = -60;
	motor[motorUL] = -60;
	motor[motorDL] = -60;
	motor[motorDR] = -60;
	wait1Msec(2000);

	motor[motorUR] = 0;
	motor[motorUL] = 0;
	motor[motorDL] = 0;
	motor[motorDR] = 0;
	wait1Msec(100);

	// Raise Flag Spinner Servo up
	servo[flagservo] = 0;
	wait1Msec(1500);
	// Spin Flag Motor CW and CCW
	motor[flag] = 60;
	wait1Msec(2500);
	motor[flag] = -60;
	wait1Msec(2500);
	motor[flag] = 0;
	// Lower Flag spinner Servo down
	servo[flagservo] = 220;
	wait1Msec(1500);

	// Testing all 4 Drive Motors, 1 turn
	distR = 1440;
	distL = 1440;
	nMotorEncoder[motorUR] = 0;
	nMotorEncoder[motorUL] = 0;
	nMotorEncoder[motorDL] = 0;
	nMotorEncoder[motorDR] = 0;
	nMotorEncoderTarget[motorUR] = distR;
	nMotorEncoderTarget[motorUL] = distL;
	nMotorEncoderTarget[motorDR] = distR;
	nMotorEncoderTarget[motorDL] = distL;
	motor[motorUR] = 30;
	motor[motorUL] = 30;
	motor[motorDR] = 30;
	motor[motorDL] = 30;


	while(nMotorRunState[motorUR] != runStateIdle && nMotorRunState[motorUL] != runStateIdle
		&& nMotorRunState[motorDR] != runStateIdle && nMotorRunState[motorDL] != runStateIdle)
	{
		//Loop till target Encoder is reached
	}

	motor[motorUR] = 0;
	motor[motorUL] = 0;
	motor[motorDR] = 0;
	motor[motorDL] = 0;
	wait1Msec(1500);

	nMotorEncoder[motorUR] = 0;
	nMotorEncoder[motorUL] = 0;
	nMotorEncoder[motorDL] = 0;
	nMotorEncoder[motorDR] = 0;
	nMotorEncoderTarget[motorUR] = distR;
	nMotorEncoderTarget[motorUL] = distL;
	nMotorEncoderTarget[motorDR] = distR;
	nMotorEncoderTarget[motorDL] = distL;
	motor[motorUR] = -30;
	motor[motorUL] = -30;
	motor[motorDR] = -30;
	motor[motorDL] = -30;


	while(nMotorRunState[motorUR] != runStateIdle && nMotorRunState[motorUL] != runStateIdle
		&& nMotorRunState[motorDR] != runStateIdle && nMotorRunState[motorDL] != runStateIdle)
	{
		//Loop till target Encoder is reached
	}

	motor[motorUR] = 0;
	motor[motorUL] = 0;
	motor[motorDR] = 0;
	motor[motorDL] = 0;

	// Raise Arm motor up 130 deg
	lastblack = true;
	while(linecnt < 13)
	{
		if(SensorValue[encoder] < threshhold)
		{

			if(lastblack == true)
			{
				linecnt++;
				lastblack = false;
			}
		}
		else
		{
			lastblack = true;
		}
		motor[arm] = 60;
	}
	motor[arm] = 0;

	servo[armleft] = 0;
	servo[armright] = 255;
	wait1Msec(1500);
	servo[pinballleft] = 128;
	servo[pinballright] = 127;
	wait1Msec(1500);
	servo[pinballleft] = 255;
	servo[pinballright] = 0;

	// Continue Raise Arm motor to 170 deg
	lastblack = true;
	while(linecnt < 17)
	{
		if(SensorValue[encoder] < threshhold)
		{

			if(lastblack == true)
			{
				linecnt++;
				lastblack = false;
			}
		}
		else
		{
			lastblack = true;
		}
		motor[arm] = 50;
	}
	motor[arm] = 0;

	servo[pinballleft] = 200;
	servo[pinballright] = 55;
	servo[armleft] = 128;
	servo[armright] = 127;
	wait1Msec(1000);
	servo[pinballleft] = 128;
	servo[pinballright] = 127;
	wait1Msec(1000);
	servo[pinballleft] = 155;
	servo[pinballright] = 100;
	wait1Msec(1000);

	servo[pinballleft] = 255;
	servo[pinballright] = 0;
	servo[armleft] = 230;
	servo[armright] = 25;

	while(SensorValue[stopper] != 1)
	{
		motor[arm] = -20;
	}
	motor[arm] = 0;
	stopit = true;
}

//******************** Dump From Ramp, Left slide (DFR_L)  **************************//
task DFR_L()
{

	// Slide left to in front of each basket
	SlideLeft(DIST_2B4, SPD_SLD, false);
	if (foundBeacon == false)
	{
		CheckBeacon();
		if (foundBeacon == true)
		{
			dist2End = DIST_2END - DIST_2B4;
			dist2Basket = DIST_1IN + DIST_B2T3 + DIST_B3T4;
		}
	}

	SlideLeft(DIST_B42B3, SPD_SLD, false);
	if (foundBeacon == false)
	{
		CheckBeacon();
		if (foundBeacon == true)
		{
			dist2End = DIST_2END - (DIST_2B4+DIST_B42B3);
			dist2Basket = DIST_1IN + DIST_B2T3;
		}
	}

	SlideLeft(DIST_B32B2, SPD_SLD, false);
	if (foundBeacon == false)
	{
		CheckBeacon();
		if (foundBeacon == true)
		{
			dist2End = DIST_2END - (DIST_2B4+DIST_B42B3+DIST_B32B2);
			dist2Basket = DIST_1IN;
		}
	}

	SlideLeft(DIST_B22B1, SPD_SLD, false);
	if (foundBeacon == false)
	{
		// last basket, No need to check
		foundBeacon = true;
		dist2End = DIST_2END - (DIST_2B4+DIST_B42B3+DIST_B32B2+DIST_B22B1);
		dist2Basket = DIST_IDK;
		lastbasket = true;
	}

	wait1Msec(200);

	SlideLeft(dist2End, SPD_SLD, false);
	MoveStraight(DIST_2LINE, SPD_STR, false);
	TurnRight(RT90, SPD_TRN, false);
	MoveStraight(DIST_2RAMP, SPD_STR, false);
	TurnRight(RT90, SPD_TRN, false);

	if(lastbasket == false)
	{
		SlideLeft(dist2Basket, SPD_SLD, false);
	}
	else
	{
		SlideRight(dist2Basket, SPD_SLD, false);
	}

	if (foundBeacon == true)
	{
		RaiseArm(14);
		Dump();
		//LowerArm(8);
		StartTask(TaskArmReset);
		servo[flagservo] = 240;
		wait1Msec(100);
	}

	stopit = true;
}

//******************** Dump From Floor, Right slide (DFR_R)  **************************//
task DFR_R()
{

	// Slide right to in front of each basket
	SlideRight(DIST_2B1, SPD_SLD, false);
	if (foundBeacon == false)
	{
		CheckBeacon();
		if (foundBeacon == true)
		{
			dist2End = DIST_2END - DIST_2B1;
			dist2Basket = DIST_1IN + DIST_B32B2R + DIST_B22B1R;
		}
	}

	SlideRight(DIST_B12B2, SPD_SLD, false);
	if (foundBeacon == false)
	{
		CheckBeacon();
		if (foundBeacon == true)
		{
			dist2End = DIST_2END - (DIST_2B1+DIST_B12B2);
			dist2Basket = DIST_1IN + DIST_B32B2R;
		}
	}

	SlideRight(DIST_B22B3, SPD_SLD, false);
	if (foundBeacon == false)
	{
		CheckBeacon();
		if (foundBeacon == true)
		{
			dist2End = DIST_2END - (DIST_2B1+DIST_B12B2+DIST_B22B3);
			dist2Basket = DIST_1IN;
		}
	}

	SlideRight(DIST_B32B4, SPD_SLD, false);
	if (foundBeacon == false)
	{
		// last basket, No need to check
		foundBeacon = true;
		dist2End = DIST_2END - (DIST_2B1+DIST_B12B2+DIST_B22B3+DIST_B32B4);
		dist2Basket = DIST_IDK;
		lastbasket = true;
	}

	wait1Msec(200);

	SlideRight(dist2End, SPD_SLD, false);
	MoveStraight(DIST_2LINE, SPD_STR, false);
	TurnLeft(LT90, SPD_TRN, false);
	MoveStraight(DIST_2B4R*2, SPD_STR, false);
	TurnLeft(LT90, SPD_TRN, false);
	if(lastbasket == false)
	{
		SlideRight(dist2Basket, SPD_SLD, false);
	}
	else
	{
		SlideLeft(dist2Basket, SPD_SLD, false);
	}

	if (foundBeacon == true)
	{
		RaiseArm(14);
		Dump();
		//LowerArm(8);
		StartTask(TaskArmReset);
		servo[flagservo] = 240;
		wait1Msec(100);
	}

	stopit = true;
}

//************************************* sandbox *******************************************//
task sandbox()
{
	SlideLeft(DIST_B42B3, 40, false);
	wait1Msec(1000);
	SlideRight(DIST_B42B3, 40, false);
}

//************************************* Speed Dump and Retreat From Floor, Left slide (SDRFF_L) *******************************************//

task SDRFF_L()
{
	MoveStraight(DIST_SFOR, SPD_STR, false);
	wait1Msec(100);

	if (foundBeacon == false)
	{
		CheckBeacon();
		if (foundBeacon == true)
		{
			dist2End = DIST_2ENDS - (DIST_B42B3); //4
		}
	}

	if (foundBeacon == false)
	{
		SlideLeft(DIST_B32B2, SPD_SLD, false);
		MoveStraight(STRAIGHT_1IN, SPD_STR, false);
		CheckBeacon();

		if (foundBeacon == true)
		{
			dist2End = DIST_2ENDS - (DIST_B42B3 + DIST_B32B2); //4
		}
	}

	if (foundBeacon == false)
	{
		SlideLeft(DIST_B12B2, SPD_SLD, false);
		foundBeacon = true;
		dist2End = DIST_2ENDS - (DIST_B42B3 + DIST_B32B2 + DIST_B22B1); //3
	}

	wait1Msec(200);

	if (foundBeacon == true)
	{
		RaiseArm(RAISENUM);
		Dump();
		//LowerArm(8);
		servo[flagservo] = 240;
		wait1Msec(100);
		LowerArm(12);


		SlideLeft(dist2End, SPD_SLD, false);
		MoveStraight(DIST_2LINE, SPD_STR, false);
		TurnRight(RT90, SPD_TRN, false);
		MoveStraight(DIST_2RAMPS, SPD_STR, false);

		if(parkfar == true)
		{
			MoveStraight(DIST_2FAR, SPD_STR, true);
		}

		ArmReset();
	}
	stopit = true;
}


//************************************* Speed Dump and Retreat From Floor, Right slide (SDRFF_R) *******************************************//

task SDRFF_R()
{
	MoveStraight(DIST_SFOR, SPD_STR, false);
	wait1Msec(100);

	if (foundBeacon == false)
	{
		CheckBeacon();
		if (foundBeacon == true)
		{
			dist2End = DIST_2ENDS - (DIST_B42B3); //
			sdrff_adj = 0;
		}
	}

	if (foundBeacon == false)
	{
		SlideRight(DIST_B22B3, SPD_SLD, false);
		TurnLeft(sdrff_adj, SPD_TRN, false);
		CheckBeacon();

		if (foundBeacon == true)
		{
			dist2End = DIST_2ENDS - (DIST_B22B3 + DIST_B42B3); //4
		}
	}

	if (foundBeacon == false)
	{
		SlideRight(DIST_B32B4-SLIDE_1IN, SPD_SLD, false);
		foundBeacon = true;
		dist2End = DIST_2ENDS - (DIST_B12B2 + DIST_B22B3 + DIST_B32B4); //3
	}

	wait1Msec(200);

	if (foundBeacon == true)
	{
		RaiseArm(RAISENUM);
		Dump();
		//LowerArm(8);
		servo[flagservo] = 240;
		wait1Msec(100);
		LowerArm(10);

		SlideRight(dist2End, SPD_SLD, false);
		MoveStraight(DIST_2LINE, SPD_STR, false);
		TurnLeft(RT90+700, SPD_TRN, false);
		MoveStraight(DIST_2RAMPS+9*STRAIGHT_1IN, SPD_STR, false);

		if(parkfar == true)
		{
			MoveStraight(DIST_2FAR, SPD_STR, true);
		}

		ArmReset();
	}

	stopit = true;
}

//******************** Dump From Floor From Same Side, Left slide (DFFFSS_L)  **************************//
task DFFFSS_L()
{

	// Slide left to in front of each basket
	if (foundBeacon == false)
	{
		SlideLeft(DIST_INT_FSS, SPD_SLD, false);
		MoveStraight(DIST_BCK_FSS, SPD_STR*-1, false);
		SlideLeft(DIST_2BK_FSS-SLIDE_1IN*4, SPD_SLD, false);
		TurnRight(100, SPD_TRN, false);
	//	MoveStraight(DIST_AF1_FSS-STRAIGHT_1IN, SPD_STR*-1, false);
	//	TurnRight(DFFFSSADJ, SPD_TRN, false);

		wait1Msec(100);
		//MoveStraight(SLIDE_1IN*-0.25,SPD_SLD*-1,false);
		CheckBeacon();
		if (foundBeacon == true)
		{
			dist2End = DIST_2END - DIST_2B4 + STRAIGHT_1IN*2;
			rt_adj = RTADJ1;
		}
	}

	if (foundBeacon == false)
	{
		SlideLeft(DIST_B42B3, SPD_SLD, false);
		MoveStraight(STRAIGHT_1IN*2, SPD_STR, false);
		TurnRight(150, SPD_TRN, false);
		wait1Msec(100);
		//MoveStraight(SLIDE_1IN*-0.5,SPD_ADJ*-1,false);
		CheckBeacon();
		if (foundBeacon == true)
		{
			dist2End = DIST_2END - (DIST_2B4+DIST_B42B3) + STRAIGHT_1IN*2;
			rt_adj = RTADJ2;
		}
	}

	if (foundBeacon == false)
	{
		SlideLeft(DIST_B32B2, SPD_SLD, false);
		wait1Msec(100);
		//MoveStraight(SLIDE_1IN*-1,SPD_ADJ*-1,false);
		CheckBeacon();
		if (foundBeacon == true)
		{
			dist2End = DIST_2END - (DIST_2B4+DIST_B42B3+DIST_B32B2) + STRAIGHT_1IN*2;
			rt_adj = RTADJ3;
		}
	}

	if (foundBeacon == false)
	{
		SlideLeft(DIST_B22B1-3*SLIDE_1IN, SPD_SLD, false);
		wait1Msec(100);
		MoveStraight(SLIDE_1IN, SPD_ADJ, false);
		// last basket, No need to check
		TurnLeft(100, SPD_TRN, false);
		MoveStraight(SLIDE_1IN, SPD_STR*-1, false);
		foundBeacon = true;
		dist2End = DIST_2END - (DIST_2B4+DIST_B42B3+DIST_B32B2+DIST_B22B1) + STRAIGHT_1IN*2;
		rt_adj = RTADJ4;
	}

	wait1Msec(200);

	if (foundBeacon == true)
	{
		//TurnLeft(LT_ADJ,30);
		RaiseArm(RAISENUM);
		Dump();
		//LowerArm(8);
		servo[flagservo] = 240;
		wait1Msec(100);
		LowerArm(12);
		//ArmReset();

		SlideLeft(dist2End, SPD_SLD, false);
		MoveStraight(DIST_2LINE, SPD_STR, false);
		TurnRight(RT90+rt_adj, SPD_TRN, false);
		MoveStraight(DIST_2RAMP-18*STRAIGHT_1IN, SPD_STR, false);

		if(parkfar == true)
		{
			MoveStraight(DIST_2FAR, SPD_STR, false);
		}

		ArmReset();

	}

	stopit = true;
}

//******************** Dump From Floor From Same Side, Right slide (DFFFSS_R)  **************************//
task DFFFSS_R()
{
	// Slide right to in front of each basket
	if (foundBeacon == false)
	{
		SlideRight(DIST_INT_FSS, SPD_SLD, false);
		MoveStraight(DIST_BCK_FSS, SPD_STR*-1, false);
		SlideRight(DIST_2BK_FSS, SPD_SLD, false);
		MoveStraight(DIST_AF1_FSS-STRAIGHT_1IN, SPD_STR*-1, false);
//		TurnLeft(DFFFSSADJ, SPD_TRN, false);

		CheckBeacon();
		if (foundBeacon == true)
		{
			dist2End = DIST_2ENDR - SLIDE_1IN*10 - DIST_2B1;
			fss_adj = 150;
		}
	}

	if (foundBeacon == false)
	{
		SlideRight(DIST_B12B2+SLIDE_1IN, SPD_SLD, false);
		MoveStraight(STRAIGHT_1IN*4, SPD_STR*-1, false);
		CheckBeacon();
		if (foundBeacon == true)
		{
			dist2End = DIST_2ENDR - SLIDE_1IN*10 - (DIST_2B1+DIST_B12B2);
		}
	}

	if (foundBeacon == false)
	{
		SlideRight(DIST_B22B3, SPD_SLD, false);
		TurnLeft(100, SPD_TRN, false);
		CheckBeacon();
		if (foundBeacon == true)
		{
			dist2End = DIST_2ENDR - SLIDE_1IN*10 - (DIST_2B1+DIST_B12B2+DIST_B22B3);
			fss_adj = 100;
			fss_arm_adj = 1;
//			MoveStraight(STRAIGHT_1IN*2, SPD_STR, false);
		}
	}

	if (foundBeacon == false)
	{
		fss_adj = 100;
		fss_arm_adj = 1;
		SlideRight(DIST_B32B4, SPD_SLD, false);
		// last basket, No need to check
		MoveStraight(STRAIGHT_1IN*2, SPD_STR*-1, false);
		foundBeacon = true;
		dist2End = DIST_2ENDR - SLIDE_1IN*10 - (DIST_2B1+DIST_B12B2+DIST_B22B3+DIST_B32B4);
	}

	wait1Msec(200);

	if (foundBeacon == true)
	{
		RaiseArm(13+fss_arm_adj);
		Dump();
		servo[flagservo] = 240;
		wait1Msec(100);
		//ArmReset();
		LowerArm(11);
		SlideRight(dist2End, SPD_SLD, false);
		MoveStraight(DIST_2LINER, SPD_STR, false);
		TurnLeft(LT90+fss_adj, SPD_TRN, false);
		MoveStraight(DIST_2RAMP - 12*STRAIGHT_1IN, SPD_STR, false);

		if(parkfar == true)
		{
			MoveStraight(DIST_2FAR, SPD_STR, true);
		}

		ArmReset();
	}

	stopit = true;
}

//********************************** ATM Menu Code ****************************************//
//0 = exit
//1 = right arrow
//2 = left arrow
//3 = big orange
task main()
{
	//nMaxRegulatedSpeedNxt = 500;
	nMotorPIDSpeedCtrl[motorUR] = mtrSpeedReg;
	nMotorPIDSpeedCtrl[motorUL] = mtrSpeedReg;
	nMotorPIDSpeedCtrl[motorDR] = mtrSpeedReg;
	nMotorPIDSpeedCtrl[motorDL] = mtrSpeedReg;
	nPidUpdateInterval = 20;
	nMotorEncoder[motorUR] = 0;
	nMotorEncoder[motorUL] = 0;
	nMotorEncoder[motorDR] = 0;
	nMotorEncoder[motorDL] = 0;
	nMotorEncoder[arm] = 0;

	// Initialize Servo positions
	servo[armleft] = 250;
	servo[armright] = 5;
	wait1Msec(200);
	servo[pinballleft] = 255;
	servo[pinballright] = 0;
	servo[flagservo] = 255;
	wait1Msec(200);

	//HitecIRS Initialize routine
	// we are going to set DSP mode to 1200 Hz.
	tHTIRS2DSPMode _mode = DSP_1200;

	// attempt to set to DSP mode.
/*	if (HTIRS2setDSPMode(HTIRS2, _mode) == 0)
	{
		// unsuccessful at setting the mode.
		// display error message.
		eraseDisplay();
		nxtDisplayCenteredTextLine(0, "ERROR!");
		nxtDisplayCenteredTextLine(2, "Init failed!");
		nxtDisplayCenteredTextLine(3, "Connect sensor");
		nxtDisplayCenteredTextLine(4, "to Port 4.");

		// make a noise to get their attention.
		PlaySound(soundBeepBeep);

		// wait so user can read message, then leave main task.
		wait10Msec(300);
		return;
*///	}

	bDisplayDiagnostics = false;
	eraseDisplay();

	while (endselect == false)
	{
		if(nNxtButtonPressed == 3 && linepos != 3)//orange
		{
			PlaySound(soundShortBlip);
			linepos++;
			wait500 = true;
		}

		else if (nNxtButtonPressed == 3 && linepos > 2)
		{
			PlaySound(soundShortBlip);
			linepos = 0;
			wait500 = true;
		}

		while(nNxtButtonPressed == 3)
		{
			wait1Msec(1000);
			buttontime++;
			if(buttontime == 3)
			{
				endselect = true;
				break;
			}
		}
		buttontime = 0;


		if (nNxtButtonPressed == 1)//right
		{
			PlaySound(soundShortBlip);
			switch (linepos)
			{
			case 0:
				if(pgmcnt <= 13)
				{
					pgmcnt++;
				}
				break;
			case 1:
				delay++;
				break;
			case 2:
				wait = true;
				waitword = "Yes";
				break;
			case 3:
				parkfar = true;
				parkword = "Far";
				break;
			}
			wait500 = true;
		}

		if (nNxtButtonPressed == 2)//left
		{
			PlaySound(soundShortBlip);
			switch (linepos)
			{
			case 0:
				if(pgmcnt >= 13)
				{
					pgmcnt--;
				}
				break;
			case 1:
				if(delay > 0)
				{
					delay--;
				}
				break;
			case 2:
				wait = false;
				waitword = "No";
				break;
			case 3:
				parkfar = false;
				parkword = "Near";
			}
			wait500 = true;
		}

		switch (pgmcnt)
		{
		case 1:
			pgmname = "DFF_L";
			break;
		case 2:
			pgmname = "DFF_R";
			break;
		case 3:
			pgmname = "DRFF_L";
			break;
		case 4:
			pgmname = "DRFF_R";
			break;
		case 5:
			pgmname = "LTTR";
			break;
		case 6:
			pgmname = "RTTR";
			break;
		case 7:
			pgmname = "Demo";
			break;
		case 8:
			pgmname = "DFR_L";
			break;
		case 9:
			pgmname = "DFR_R";
			break;
		case 10:
			pgmname = "sandbox";
			break;
		case 11:
			pgmname = "SDRFF_L";
			break;
		case 12:
			pgmname = "SDRFF_R";
			break;
		case 13:
			pgmname = "DFFFSS_L";
			break;
		case 14:
			pgmname = "DFFFSS_R";
			break;
		default:
			pgmname = "ERROR";
			break;
		}

		select1 = "";
		select2 = "";
		select3 = "";
		select4 = "";

		switch (linepos)
		{
		case 0:
			select1 = "*";
			break;
		case 1:
			select2 = "*";
			break;
		case 2:
			select3 = "*";
			break;
		case 3:
			select4 = "*";
			break;
		}

		//StringFormat(stngfmt, "%s: %s", "Program: ", pgmname);
		//nxtDisplayTextLine(0, stngfmt);
		//StringFormat(stngfmt, "%s: %d", "Delay: ", delay);
		//nxtDisplayTextLine(1, stngfmt);
		//StringFormat(stngfmt, "%s: %s", "WaitForStart: ", waitword);
		//nxtDisplayTextLine(2, stngfmt);

		nxtDisplayTextLine(0, "Program: %s %s", pgmname, select1);
		nxtDisplayTextLine(1, "Delay: %d %s", delay, select2);
		nxtDisplayTextLine(2, "Wait: %s %s", waitword, select3);
		nxtDisplayTextLine(3, "Park: %s %s", parkword, select4);


		if (wait500 == true)
		{
			wait1Msec(300);
			wait500 = false;
		}
	}
	eraseDisplay();
	if (wait == true)
	{

		nxtDisplayBigTextLine(1, "Good");
		nxtDisplayBigTextLine(3, "Luck!");
		//waitForStart();
	}

	wait1Msec(delay*1000);

	switch (pgmcnt)
	{
	case 1:
		StartTask(DFF_L);
		break;
	case 2:
		StartTask(DFF_R);
		break;
	case 3:
		StartTask(DRFF_L);
		break;
	case 4:
		StartTask(DRFF_R);
		break;
	case 5:
		StartTask(LTTR);
		break;
	case 6:
		StartTask(RTTR);
		break;
	case 7:
		StartTask(Demo);
		break;
	case 8:
		StartTask(DFR_L);
		break;
	case 9:
		StartTask(DFR_R);
		break;
	case 10:
		StartTask(sandbox);
		break;
	case 11:
		StartTask(SDRFF_L);
		break;
	case 12:
		StartTask(SDRFF_R);
		break;
	case 13:
		StartTask(DFFFSS_L);
		break;
	case 14:
		StartTask(DFFFSS_R);
		break;
	}

	while(stopit == false){}
}
